<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>UNKNOWN SIGNAL - Responsive</title>
    <style>
        body{font-family: "Courier New", monospace; margin:0; padding:16px; background:#000; color:#fff; display:flex; flex-direction:column; align-items:center;}
        h1{margin:6px 0;font-size:clamp(18px,4vw,26px);}
        #game-container{width:100%; max-width:720px; margin-top:12px;}
        canvas{width:100%; height:auto; display:block; border-radius:4px; border:2px solid #555; background:#050505; touch-action:none;}
        .controls{width:100%; max-width:720px; margin-top:12px; text-align:center;}
        button{padding:10px 18px; font-size:15px; border-radius:6px; background:#222; color:#ccc; border:1px solid #555;}
        .status{margin-top:10px; color:#fff; text-shadow:0 0 5px #fff; min-height:1.2em;}
    </style>
</head>
<body>
    <h1>UNKNOWN SIGNAL</h1>
    <div id="game-container"><canvas id="gameCanvas"></canvas></div>
    <div class="controls">
        <button id="resetBtn">RESET SYSTEM</button>
        <div id="status" class="status"></div>
    </div>

<script>
const GRID_SIZE = 6;
let CELL_SIZE = 60;
const MONO_COLOR = '#FFFFFF';
const level = [
    ['A', 0, 'C','D','E', 0],
    ['B', 0,  0,  0, 'D', 0],
    [ 0,  0,  0,  0,  0,  0],
    [ 0,  0,  0,  0,  0,  0],
    [ 0,  0, 'B', 0,  0,'E'],
    ['A', 0,  0,  0,  0,'C']
];

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const statusDiv = document.getElementById('status');
const resetBtn = document.getElementById('resetBtn');

let paths = [];
let completedPaths = [];
let isDrawing = false;

function resizeCanvas(){
    const dpr = window.devicePixelRatio || 1;
    const containerWidth = Math.min(window.innerWidth*0.95, 720);
    const maxByHeight = window.innerHeight * 0.7;
    const target = Math.min(containerWidth, maxByHeight);
    CELL_SIZE = Math.max(28, Math.floor(target / GRID_SIZE));
    const logicalW = CELL_SIZE * GRID_SIZE;
    canvas.style.width = logicalW + 'px';
    canvas.style.height = logicalW + 'px';
    canvas.width = logicalW * dpr;
    canvas.height = logicalW * dpr;
    ctx.setTransform(dpr,0,0,dpr,0,0);
    draw();
}

function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // grid
    ctx.strokeStyle = "#111";
    ctx.lineWidth = 1;
    for(let i=0;i<=GRID_SIZE;i++){
        ctx.beginPath(); ctx.moveTo(i*CELL_SIZE,0); ctx.lineTo(i*CELL_SIZE, CELL_SIZE*GRID_SIZE); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0,i*CELL_SIZE); ctx.lineTo(CELL_SIZE*GRID_SIZE, i*CELL_SIZE); ctx.stroke();
    }
    // completed + current
    ctx.strokeStyle = MONO_COLOR;
    ctx.lineWidth = Math.max(8, CELL_SIZE*0.18);
    ctx.lineCap = "round"; ctx.lineJoin = "round";
    completedPaths.concat(isDrawing ? [paths] : []).forEach(path=>{
        if(path.length>0){
            ctx.beginPath();
            ctx.moveTo(path[0].x*CELL_SIZE + CELL_SIZE/2, path[0].y*CELL_SIZE + CELL_SIZE/2);
            for(let i=1;i<path.length;i++) ctx.lineTo(path[i].x*CELL_SIZE + CELL_SIZE/2, path[i].y*CELL_SIZE + CELL_SIZE/2);
            ctx.stroke();
        }
    });
    // dots
    for(let y=0;y<GRID_SIZE;y++){
        for(let x=0;x<GRID_SIZE;x++){
            if(level[y][x] !== 0){
                ctx.fillStyle = MONO_COLOR;
                ctx.beginPath();
                ctx.arc(x*CELL_SIZE + CELL_SIZE/2, y*CELL_SIZE + CELL_SIZE/2, CELL_SIZE/4, 0, Math.PI*2);
                ctx.fill();
            }
        }
    }
}

function getPosFromEvent(e){
    let cx, cy;
    if(e.touches && e.touches.length){ cx = e.touches[0].clientX; cy = e.touches[0].clientY; }
    else if(e.changedTouches && e.changedTouches.length){ cx = e.changedTouches[0].clientX; cy = e.changedTouches[0].clientY; }
    else { cx = e.clientX; cy = e.clientY; }
    const rect = canvas.getBoundingClientRect();
    const x = Math.floor((cx - rect.left) / CELL_SIZE);
    const y = Math.floor((cy - rect.top) / CELL_SIZE);
    return {x,y};
}
canvas.style.touchAction = 'none';

function onPointerDown(e){
    e.preventDefault();
    const pos = getPosFromEvent(e);
    if(pos.x<0||pos.x>=GRID_SIZE||pos.y<0||pos.y>=GRID_SIZE) return;
    if(level[pos.y][pos.x] !== 0){
        paths = [pos];
        isDrawing = true;
        statusDiv.innerText = "";
        draw();
    }
}
function onPointerMove(e){
    if(!isDrawing) return;
    e.preventDefault();
    const pos = getPosFromEvent(e);
    if(pos.x<0||pos.x>=GRID_SIZE||pos.y<0||pos.y>=GRID_SIZE) return;
    const last = paths[paths.length-1];
    const dx = Math.abs(pos.x - last.x), dy = Math.abs(pos.y - last.y);
    if((dx===1 && dy===0) || (dx===0 && dy===1)){
        const existingIndex = paths.findIndex(p=>p.x===pos.x && p.y===pos.y);
        if(existingIndex !== -1) paths = paths.slice(0, existingIndex + 1);
        else paths.push(pos);
        if(level[pos.y][pos.x] !== 0 && paths.length>1){
            completedPaths.push([...paths]);
            isDrawing = false;
            checkWin();
        }
    }
    draw();
}
function onPointerUp(e){
    isDrawing = false;
    draw();
}
function checkWin(){
    let filled = new Set();
    completedPaths.forEach(p => p.forEach(q => filled.add(`${q.x},${q.y}`)));
    if(filled.size === GRID_SIZE * GRID_SIZE){
        statusDiv.innerText = "ACCESS GRANTED: [キーワード: GHOST]";
    }
}
function resetGame(){
    paths = [];
    completedPaths = [];
    isDrawing = false;
    statusDiv.innerText = "";
    draw();
}
function setup(){
    window.addEventListener('resize', resizeCanvas);
    canvas.addEventListener('pointerdown', onPointerDown);
    window.addEventListener('pointermove', onPointerMove, {passive:false});
    window.addEventListener('pointerup', onPointerUp);
    canvas.addEventListener('touchmove', e=>e.preventDefault(), {passive:false});
    resetBtn.addEventListener('click', resetGame);
    resizeCanvas();
}
setup();
</script>
</body>
</html>
